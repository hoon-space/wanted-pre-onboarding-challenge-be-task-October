**✍️ 본인이 주력으로 사용하는 언어에서 자료구조와 관련 된 클래스가 내부적으로 어떻게 동작하는지 한 가지 사례를 정하여 작성해주세요.**

***ArrayList***

```
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable {

    private static final int DEFAULT_CAPACITY = 10;
    
    private static final Object[] EMPTY_ELEMENTDATA = {};
    
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    
    transient Object[] elementData; // transient? 직렬화 시 특정 멤버변수를 무시하고 싶은 경우 사용하는 키워드
    
    private int size;
    
    public ArrayList(int initialCapacity) { // 파라미터로 특정 배열 사이즈를 전달함
        if (initialCapacity > 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity);
        }
    }
    
    public ArrayList() { // 기본 생성자
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; // add 메서드로 첫번째 element가 입력되면 기본 사이즈는 10으로 변경됨 
    }
    
    public ArrayList(Collection<? extends E> c) { // 파라미터로 특정 컬렉션을 전달함
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }
    
    ...
    
    public boolean add(E e) {
        ensureCapacityInternal(size + 1); // 내부적으로 배열 사이즈를 계산하고 동적으로 증가시킴
        elementData[size++] = e;
        return true;
    }
    
    private static int calculateCapacity(Object[] elementData, int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        return minCapacity;
    }
    
    private void ensureCapacityInternal(int minCapacity) {
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }
    
    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        if (minCapacity - elementData.length > 0) // 배열 사이즈를 초과한다면 grow 메서드를 호출함
            grow(minCapacity);
    }
    
    private void grow(int minCapacity) {
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1); // 기존 사이즈 대비 50% 증가
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity); // Integer.MAX_VALUE or Integer.MAX_VALUE - 8 반환됨
        elementData = Arrays.copyOf(elementData, newCapacity); // System.arraycopy 메서드 호출, GC가 발생할 수 있으니 사용에 주의할 것
    }
    
    public E remove(int index) {
        rangeCheck(index);

        modCount++; // Iterator가 생성될 때 expectedModCount로 사용되고 자료구조에 변경이 생기면 checkForComodification 예외가 발생함
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index, numMoved); // 마지막 위치를 제외하고 배열 복사 발생
        elementData[--size] = null;  // 사용하지 않는 경우 null 처리함

        return oldValue;
    }
    
    public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index < size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            for (int index = 0; index < size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }
```

***HashSet***

```
public class HashSet<E>    
    extends AbstractSet<E>
    implements Set<E>, Cloneable, java.io.Serializable {

    private transient HashMap<E,Object> map;

    private static final Object PRESENT = new Object(); // Dummy value
    
    public HashSet() {
        map = new HashMap<>(); 내부적으로 HashMap을 생성하고
    }
    
    ...
    
    public boolean contains(Object o) {
        return map.containsKey(o);
    }
    
    public boolean add(E e) { // add 메서드를 통해 값을 삽입하는데
        return map.put(e, PRESENT)==null; // 실제로는 Map의 put 메서드가 호출됨
    }
    
    public boolean remove(Object o) {
        return map.remove(o)==PRESENT;
    }
    
    ...
```
