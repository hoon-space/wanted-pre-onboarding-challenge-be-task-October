## 주력 언어(Javascript)의 한가지 자료구조(Array)의 내부적 동작 

### Array

JS의 Array는 key가 int 타입 인덱스인 특수한 Object이다. 

이를 좀 더 상술하면 C,Java의 Array가 크기와 타입이 정해진 정적(static) 배열인 반면 JS의 배열은 크기와 타입이 고정되어 있지 않고 서로 다른 타입의 데이터들이 배열의 요소가 될 수도 있다. 즉 JS의 배열은 길이가 얼마든지 늘어나거나 줄어들 수 있기 때문에 밀집도는 보장되지 않는다. 

또한 zero-indexed 성질을 가진다는 점(첫번째 요소가 인덱스 0), 복사시 얕은 복사가 일어난다는 점도 JS의 Array의 특징이다. 

object라는 성질은 배열의 요소가 객체의 속성(object properties)이라는 점에서 드러난다. 그러나 JS는 명시적으로 dot notation 대신 bracket notation을 사용하는 숫자를 쓴다고 밝히고 있어 일반적인 CS언어의 객체와는 다른 점이 있다.

Array는 global object의 특수한 객체(하나의 property)이고 배열 인스턴스를 만드는 constructor로 사용할 수 있다. 즉, 

const exampleArray = new Array() 처럼 배열을 만들 수 있다는 의미이다. 이때 exampleArray는 크기가 0인 배열이 된다.

이렇게 선언만 되고 값이 할당되지 않은 exampleArray에는 운영 체제가 메모리를 할당한다. 이때 자료 유형에 따라 immutable한 영역(String, Number, Boolean, undefined, null)과 mutable한 영역(Array, Function, Object)로 구분되는데 Array는 차지하는 메모리의 크기가 가변적(mutable)하다.

만약
```
 exampleArray[0] = 'wanted';
 exampleArray[99] = 'onboarding';
 ```
 라고 값을 할당하면 JS에선 mutable하게 메모리를 할당하므로 내부에선 연속적으로 이들 데이터가 저장되지 않는다. 따라서 exampleArray[99]의 값을 읽으려면 처음 new Array()에서 할당된 메모리주소에서 exampleArray[99](해시를 통해 계산된 주소를 가지게 됨)를 탐색해 나가면서 찾는 것이다. wanted나 onboarding 같은 요소를 위한 각 메모리 공간은 같은 크기도 아니고 연속적으로 이어져 있지도 않다. 이런 점에서 배열을 특수한 객체라고 한다.
 
```
let exampleArray2 = exampleArray;
```
위와 같이 exampleArray2를 선언하면 배열은 객체처럼 참조를 복사한다. 그리고 새로운 요소가 들어온다면 배열의 요소를 인접한 메모리 공간에 차례로 저장해 연산 속도를 높이게 된다. 

 그리고 더이상 메모리를 사용하지 않으면(정확히는 더이상 참조되지 않으면) garbage collection이 이 메모리를 해제하게 된다. 



