## 1. 동시에 같은 `DB Table row` 를 업데이트 하는 상황을 방어하기 위해 어떻게 개발하실 건지 설명해주세요.

####  Lock을 통해 트랜잭션 처리의 순차성을 보장하여 동시성 문제를 예방한다.



1. Spring Framework의 경우 **@Transactional 어노테이션**을 통해 동시성 문제를 해결 할 수 있다.

   @Transactional 어노테이션은 트랜잭션의 고립 레벨을 설정해주고, 트랜잭션에 문제가 발생할 때 rollback 시킬 수 있으며 동시성 문제를 예방해줄 수 있다. 고립 레벨은 0~3까지 총 4개의 레벨로 이루어진다.

   4가지 레벨 중 Level 3의 **SERIALIZABLE**를 사용하면 트랜잭션을 다른 트랜잭션으로부터 완전히 분리시켜 특정 트랜잭션이 작업 중인 동안에 다른 트랜잭션은 접근을 할 수 없게 되어, 동시에 같은 Table row를 업데이트 하는 상황을 방어할 수 있다. 그러나, **고립성이 높아지는 만큼 동시성이 낮아져 성능이 떨어지기 때문**에 SERIALIZABLE 고립 레벨은 거의 사용하지 않는다.

2. 쿼리에서 for update를 사용하여 명시적으로 lock을 건다.

   쿼리에서 For Update를 사용하여 트랜잭션 수행동안 락을 걸면, 멀티 스레드 환경에서도 리소스를 점유하여 다른 트랜잭션에서 동시에 업데이트 하는 상황을 방어할 수 있다. 그러나 이 방법도 lock을 잡는 구간이 길어져 성능에 영향을 끼칠 수 있다.

3. 테이블에 version 컬럼을 만들어서 동시 업데이트 방어

   테이블에 version이라는 숫자 컬럼을 생성하여 수정될 때마다 1씩 증가하게 한다.

   이 때 version이 동일하면 수정이 가능하고 동일하지 않으면 수정이 실패하게 하여 affected row count가 0이 되면 요청을 재시도하도록 구현하여 동시 업데이트를 방어할 수 있다.



	### 참조

https://kth990303.tistory.com/313
https://sweeeetgoguma.tistory.com/entry/20220602-%E3%80%8CDB-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C%E3%80%8D







