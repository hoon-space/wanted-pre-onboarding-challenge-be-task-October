1. 비관적락  
    동시성 문제는 DB에서 같은 내용을 동시에 읽었을 떄 발생합니다.  
    이를 방지하기 위해 “select for update” 쿼리를 사용하여 대상 테이블을 읽고나서  DB 락을 겁니다.  
    이를 통해 먼저 접근한 트랜잭션이 커밋 또는 롤백될떄 까지 다른 트랜잭션에서 해당 테이블을 읽을 수 없습니다.  
    DB에 Lock을 거는 것은 높은 동시성을 보장하지만 성능에 매우 치명적이기 때문에  
    성능이 중요시되는 요즘 서비스에서는 잘 사용되지 않습니다.
    
    다만 구현이 매우 쉽고 높은 정합성을 보장히기 떄문에  
    성능이 중요하지 않다면 이 방식을 사용하겠습니다.  
    
2. 낙관적락  
    충돌이 발생하지 않는다고 가정하고 DB 가 제공하는 락 기능이 아니라 어플리케이션에서 제공하는 버전 관리 기능을 사용하여 동시성을 제어하는 방법입니다.  
    트랜잭션에서 row를 수정 할 때 어플리케이션 레벨의 필드에 Version을 기입해둡니다.  
    만약 해당 Row를 조회했을 때의 버전과 수정했을 때의 버전이 다르다면 다른 트랜잭션에서 중간에 이미  수정한 것이기 때문에 예외가 발생합니다.  
    낙관적락은 DB가 아닌 어플리케이션 레벨의 영역이기 때문에 트랜잭션 롤백을 지원하지 않습니다.  
    따라서 충돌이 발생하였을 떄 발생하는 예외를 잡아서 개발자가 직접 처리해주어야 합니다.  
    성능은 비관적락을 사용할떄 보다 좋지만  
    트랜잭션 롤백을 지원해주지 않아서 어플리케이션 레벨에서 수동으로 충돌을 처리해야 하기 떄문에  
    충돌이 자주 발생할 것으로 예상되거나 한 트랜잭션에 물려있는 로직이 많을 경우(수동으로 롤백 처리할 로직이 많을 경우) 오히려 성능이 더 나쁠 수 있습니다.  
    
    
    정리하자면 해당 로직의 트랜잭션에 물려있는 로직이 적고  
    단일 서버로 운영되는 경우 낙관적락을 통해 동시성을 제어하겠습니다.  
    

1. 분산락  
    여러대의 서버로 운영되는 분산시스템에서 동시정을 제어하기 위해 사용되는 방법입니다.  
    여러 서버가 바라보는 공통 데이터 저장소에 락을 걸어서 동시에 들어오는 요청을 순차처리하는 방법입니다.  
    공통 저장소에는 DB, Redis 등이 있을 수 있습니다.  
    저라면 DB에 락을 거는 것은 성능에 큰 영향을 미치기 떄문에  
    DB보다 성능이 빠른 Rerdis에 락을 걸겠습니다.  
    RedisClient로는 스핀락을 사용하는 Lettuce 보다는 타임아웃을 지정해서 데드락을 예방할 수 있고 Pub/Sub 방식으로 CPU의 부하가 적은  Redisson을 사용하겠습니다.  
    
    
    구현방식은 첫번째 요청이 왔을 떄 수정하려는 Row의 PK를 가지고 특정 규칙을 통해 RedisKey를 생성하고 해당 Key에 레디스 락을 겁니다.  
    두번째 요청이 오면 PK를 통해 Key를 생성하고 Lock 획득을 시도합니다.  
    흭득하지 못했다면 기다렸다가 Lock을 얻었을 시 로직을 처리하도록 구현하겠습니다.
