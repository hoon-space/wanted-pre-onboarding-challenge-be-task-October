
## 동시에 같은 DB Table row 를 업데이트 하는 상황을 방어하기 위해 어떻게 개발하실 건지 설명해주세요.  
### 1. 기본 설명  
DB들은 일반적으로 다수의 클라이언트가 같은 DB 접근(read/write)가 가능하도록 설계되어 있다.  
하나의 DB에 하나의 클라이언트만 접근 가능한 식으로 되어 있다면 DB를 사용하는 부분에서 병목 현상이 심하게 일어나므로, 이는 어느 정도 필연적이라 볼 수 있다.  
하지만, 그에 따라 `concurrency` 문제가 발생하게 된다. 이는 여러 클라이언트가 같은 데이터에 동시에 접근하려 할 때 일어난다.  

이 문제가 어떻게 발생하는지 알아보고, `MongoDB`에서 어떤 해결책을 제시하였는지 알아보자.  
  
---  
  
### 2. MongoDB의 Concurrency 문제 해결방법  
  
`MongoDB`는 여러 클라이언트가 동시에 같은 데이터를 읽을 수 있도록 설계되어 있다. (쓰기는 한번에 한 개의 클라이언트만 가능하다)  
  
`consistency`를 보장하기 위해   
1.`lock`  
2.`concurrency control`  
이 두 가지를  사용한다고 한다.  
  
---  
  
#### 1. lock  
  
1. `MGL(Multi Granular Lock)` 을 사용한다.   
이는 접근 시 모든 DB에 접근 못하게 하는 것이 아니라 모든 단계(db, collection, document 단계)마다 `락`을 걸 수 있다는 말이다.  
  
2. `reader-writer lock`  
락의 동기화에는 `RW lock`을 사용한다.  
  
>  - read-only에는 동시에 접근.   
	 - shared Lock `S`라 한다  
>- write에는 exclusive access(독점접근)을 사용한다.   
	- exclusive lock `X` 라 한다.  
  
간단히,  
>- read-only 접근을 하면 read-lock `S`을 걸고, 모든 다른 read 접근을 동시에 접근해도 상관없도록 허용해준다.  
>- write로 접근하면, write `X`락을 걸고, 모든 다른 접근을 허용하지 않는다.  
  
이러한 개념에 조금 더 추가해서, `IS`락과 `IX`락이 존재한다.   
이 두 락은 `MGL`에 의해 필요하다.   
예를 들면,  
  
>1. 한 클라이언트가 document A에 `S`락을 걸고 `read`작업을 한다.  
>2. 이 작업을 하기 위해, document의 모든 상위 레벨의 계층(collection, db)는 `IS`가 걸린다.  
  
이런 식으로 작동된다. `X` 와 `IX`도 마찬가지이다.  
  
이 4종류의 락이 상호적으로 같이 있을 수도 있고, 같이 존재하지 못할 경우도 있다.  
이에 대한 자세한 내용은 [공식사이트](https://www.mongodb.com/docs/v6.0/faq/concurrency/)에서 확인 가능하다.  
  
모든 클라이언트의 요청은 조금 변형된 `큐`에 의해 관리된다.  
공식 사이트에 따르면,
 `S`락이 걸려있을 경우, 뒤의 동시에 처리가능한 `S`, `IS`락은 같이 처리된다.  
이러한 약간의 예외 상황 외에는 `큐`의 `FIFO`를 따라간다고 생각하면 된다.  
  
---  
  
#### 2. Concurrency Control  
  
동시성 컨트롤에는 두종류가 있다.  
>- OCC (optimistic concurrency control)  
>- PCC (pessimistic concurrency control)  
  
두 가지가 장단점이 확실하여 상황에 맞게 쓰인다.  
자세한 내용보다는, 간단한 특징점 비교만 하고 넘어간다.  
  

>OCC   
>- 속도가 중요한 곳에 주로 사용  
>- 개발자가 조금 불편함(에러처리 부분)  
    
>PCC  
>- DB Consistency가 속도보다 중요할 때 쓰인다.  
>- 개발자 입장에서 편하다(한번의 접근에 모든 락을 걸기 때문에 consistency에 대한 처리가 거의 없다)  
  
`MongoDB`는 `OCC`를 채택하였다.   
충돌이 발생 했을 때 한쪽이 조금 기다렸다가 다시 `write`을 하는 형식으로 진행된다.  
  
  
---  
  
### 결론  
`concurrency` 문제는 동시에 오는 작업에 대한 순서처리로 생각 할 수 있다.  
해결 방법으로 `lock`과 `OCC` 등의 방법으로 해결이 가능하다.  
`MongoDB`는 하나의 document에 대한 작업은 `atomic`하게 작동한다.  
고로, 동시에 오는 작업이라도 일관성있는 순서 제어를 해주면 문제없이 동작 가능하다.  
  

 
  ---
### 추가내용  
동시성문제 외에도 find and modify라는 문제가 있다.

---  
  
### 1. 문제상황 예시  

일반인 A의 잔고가 1000원인 상황에서  
  
|사람|행동|  
|--|--|   
|일반인 A|통장에 1000원을 입금하려한다|  
|은행사직원 B |통신비 500원을 A의 통장잔고에서 빼서 다시 통장 잔고로 저장해야한다.|  
   
이 두 사람이 거의 비슷한 시간에 각각의 행동을 할 때 어떻게 문제가 되는지 알아보자.   
  
> 1. 일반인 A가 계좌 잔고를 확인(read)한다. 이때 1000원이 찍힌다.  
2. 은행사직원 역시 현재 잔고를 확인(read)하기위해 잔고를 조회한다. 마찬가지로 1000원이다.  
3. 일반인 A가 1000원을 입금한다. 현재 2000원이 되어, 이 값을 저장한다(write). 현재 `DB`에는 2000원이 저장된다.  
4. 은행사직원 역시 500원을 빼서 저장한다. 1000-500의 값을 `DB`에 저장한다(write). 현재 `DB`는 500원이 된다.  
  
이런식으로 언제 read가 되고, 언제 write가 되는지에 따라 이상적인 값과 완전 다른 값이 될 수 있다.  
  
---  
  
### 2. 해결방안  
    
몽고디비에서, find와 modify를 한번에 작동하게 하도록 하는 명령어가 따로 있다.   
`db.collection.findAndModify`  
위의 명령어로 작업을 할 경우, 찾기와 그값을 바꾸는 작업을 `tomic`하게 작업이 가능하다.  
  
하나의 `document`에 대한 문제는 해결되었다.   
여러 `document`에 대해서는 공식문서에 transaction이라는 파트가 있는데 이를 참고하면 된다.  

  
### 참고자료  
https://ozt88.tistory.com/36  
https://www.mongodb.com/docs/v6.0/faq/concurrency/  
https://www.mongodb.com/docs/manual/core/transactions/  
