## 'naver.com’ IP 조회
1. 내부에 저장된 DNS 서버 IP 주소를 검색한 뒤 로컬 IP 주소와 DNS 서버 IP 주소의
네트워크 ID 를 자신의 서브넷 마스크를 이용해 비교한다. 출발지와 목적지의
네트워크 ID가 다르기 때문에 DNS 서버로 가기 위해 ARP 테이블에서 라우터의
MAC 주소를 검색한다.
2. ARP 캐시 테이블에서 라우터의 MAC 주소를 검색할 수 없다면, 네트워크
계층에서는 1개의 ARP 요청 헤더를 생성해 데이터 링크 계층으로 ARP 헤더를
넘긴다.
3. 데이터 링크 계층에서는 네트워크 계층으로부터 넘오온 ARP 헤더 앞뒤로 각각
헤더와 트레일러를 추가해, 1개의 이더넷 프레임을 생성한 뒤 물리 계층으로 이더넷
프레임을 넘긴다.
4. 물리 계층에서는 데이터 링크 계층으로부터 넘어온 이더넷 프레임을 비트로 변환한
뒤 브로드캐스트 방식에 따라 ARP 요청을 LAN 영역 전체로 전송한다. 라우터는
자신의 MAC 주소를 담아 송신자에게 유니캐스트 방식으로 ARP 응답을 전송한다.
5. 라우터로부터 ARP 응답이 오면 ARP 헤더에서 목적지 MAC 주소를 추출해 ARP
캐시 테이블에 반영한다.
6. 응용 계층에서는 UDP 속성에 따라 도메인 네임 질의 정보를 담은 1개의 DNS
페이로드를 생성한 뒤 전송 계층으로 DNS 페이로드를 넘긴다.
7. 전송 계층에서는 응용 계층으로부터 넘어온 DNS 페이로드 앞에 UDP 헤더(53번
포트번호)를 추가해, 1개의 UDP 데이터그램을 생성한 뒤 네트워크 계층으로 UDP
데이터그램을 넘긴다.
8. 네트워크 계층에서는 전송 계층으로부터 넘어온 UDP 데이터그램 앞에 IP 헤더를
추가해, 1개의 IP 패킷을 생성한 뒤 데이터 링크 계층으로 넘긴다.
9. 데이터 링크 계층에서는 네트워크 계층으로부터 넘어온 IP 패킷 앞뒤로 각각 헤더와
트레일러를 추가해, 1개의 이더넷 프레임을 생성한 뒤 물리 계층으로 이더넷
프레임을 넘긴다.
10. 물리 계층에서는 데이터 링크 계층으로부터 넘어온 이더넷 프레임을 비트로 변환한
뒤 유니캐스트 방식에 따라 라우터로 해당 비트를 전송한다.
11. 라우팅을 거쳐 목적지 DNS 서버로부터 도메인 네임 질의에 대한 응답이 오면, 해당
IP 주소를 DNS 캐시 테이블에 반영한다.
## 소켓 연결 (TCP 3 handshake)
1. 전송 계층에서 SYN 플래그와 포트 번호를 설정한 1 개의 TCP 헤더를 생성해
네트워크 계층으로 TCP 헤더를 넘긴다.
2. 네트워크 계층에서는 TCP 헤더 앞에 IP 헤더를 추가해, 1 개의 IP 패킷을 생성한 뒤
데이터 링크 계층으로 넘긴다.
3. 데이터 링크 계층에서는 ARP 캐시 테이블을 참조해 IP 패킷 앞뒤로 헤더(MAC
주소)와 트레일러를 추가해 1 개의 이더넷 프레임을 생성한 뒤 물리 계층으로
넘긴다.
4. 물리 계층에서는 이더넷 프레임을 비트로 변환한 뒤 유니캐스트 방식에 따라
라우터로 해당 비트를 전송한다.
5. 목적지 웹 서버로부터 SYN/ACK 플래그를 수신하면 전송 계층에서는 ACK 플래그와
포트 번호를 설정한 1개의 TCP 헤더를 생성해 네트워크 계층으로 TCP 헤더를 넘겨
위(2~4) 과정을 수행한다.
## SSL handshake(TCP 연결 후에 진행)
TCP 패킷을 SSL 프로토콜을 통하여 주고 받는다. SSL 프로토콜의 방식을 통해
클라이언트와 서버가 주고 받는 실제 정보는 대칭키 방식으로 암호화하고, 대칭키 방식으로
암호화된 실제 정보를 복호화할때 사용할 대칭키는 공개키 방식으로 암호화해서
클라이언트와 서버가 주고 받는다.
1. 클라이언트가 생성한 랜덤 데이터(A), 사용 가능한 암호화 방식 후보들, 이미 SSL
handshaking을 했다면 그때 생성된 세션 ID를 서버로 송신한다.
2. 서버가 생성한 랜덤 데이터(B), 서버가 선택한 클라이언트 암호화 방식, 서버의
공개키가 담긴 인증서를 클라이언트로 송신한다.
3. 클라이언트는 클라이언트에 내장된 CA 리스트를 확인한다. CA 리스트에 서버로
부터 수신한 인증서가 없다면 사용자에게 경고 메세지를 출력한다. 리스트에 있다면
서버가 송신한 인증서가 CA에 의해 발급 된 것인지 확인하기 위해서 클라이언트에
내장된 CA의 공개키를 이용해서 인증서를 복호화한다. 복호화에 성공한다면
인증서는 CA의 개인키로 암호화된 문서임을 보증한다. 따라서 인증서를 송신한
서버를 신뢰할 수 있다.
4. 클라이언트는 랜덤 데이터들(A,B) 을 조합해서 pre master secret 키(대칭키)
생성한다. 그리고 서버로 부터 수신한 인증서 안에 들어있는 공개키를 이용하여 pre
master secret 값을 암호화 하여 서버로 전송한다.
5. 서버는 자신의 비공개 키로 pre master secret 값을 복호화한다.
6. 서버와 클라이언트는 각각 pre master secret 값으로 master secret 생성. master
secret 값으로 session key(대칭키) 생성한다.
7. 클라이언트와 서버는 종료 메세지를 session key 로 암호화하여 서로에게 전송한다.
8. SSL handshake 종료
## 데이터 송수신
* 응용 계층에서 작성되는 페이로드(요청 메세지) 형식  
<메서드> <요청 URL> <버전> CRLF
<헤더> CRLF
<엔티티 본문> CRLF    
* 데이터 전송  
1. 응용 계층에서 작성한 페이로드를 SSL 계층으로 넘겨 session key 로 암호화 한 뒤
전송 계층으로 넘긴다.
2. 전송 계층에서는 flow control과 congestion control을 위해 넘겨받은 페이로드를 여러
개로 단편화한다. 단편화 된 각 페이로드에 TCP 헤더를 추가하여 여러 개의 TCP
세그먼트를 생성한 뒤 네트워크 계층으로 TCP 세그먼트를 넘긴다. 각 하위 계층
작업을 거쳐 서버에 전송한다.  
* 메인 서버 응답  
1. 서비스 앞 단의 로드 밸런서가 요청 트래픽을 분산 시켜 뒷 단의 웹 서버로 요청을
전달한다.
2. 요청을 전달 받은 웹 서버에서 역캡슐화 되어 올라온 요청 메세지를 해석한 뒤
요청을 처리한다.
3. 응답 내용을 로드 밸런서로 송신한다.
4. 로드 밸런서는 클라이언트에게 응답을 송신한다.  
* 데이터 수신 (응답 메세지) 형식  
<버전> <상태 코드> <사유 구절> CRLF
<헤더> CRLF
<엔티티 본문> CRLF
## 브라우저 렌더링
1. 응답 성공시 엔티티 본문을 읽어와서 구문 분석 (HTML, CSS, JS) 후에 렌더링을 (
DOM Tree 구성 - 렌더 트리 구성 - 렌더트리 레이ᄒ아웃 배치 - 렌더트리 그리기 )
한다.
2. 링크를 추출하고 각 주소 마다 DNS 조회부터 수행하여 정적파일(.js 파일,
이미지)들은 cdn 서버로부터 다운 받는다.
3. javascript 를 실행하여 비동기적으로 리소스 요청을 수행한다.
