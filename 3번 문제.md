(3) 웹 브라우저에 네이버를 검색하고 화면에 네이버 화면이 출력이 될 때 까지 내부적으로 어떤 동작들이 수행이 되는지 설명해주세요.

## 웹 브라우저에서 네이버를 검색했을 경우

네이버와 같이 특정한 단어로 검색하는 브라우저에서의 검색은 주기적으로 웹 콘텐츠를 크롤링을 통해 수집합니다. 검색 서비스가 수집한 웹사이트 중 유저가 입력한 검색어에 제일 의도가 일치한 웹사이트에 순위를 매기고 적절한 방법으로 결과를 화면에 노출합니다. 

구글의 경우 Googlebot, 네이버의 경우 네이버 검색로봇이 웹 사이트들의 정보를 수집합니다.
네이버의 네이버 검색로봇은 웹 상의 사이트를 발견하고 발견한 사이트에 접근 및 정보를 수집해 로직에 따라서 검색 결과를 반영합니다.


## 웹 브라우저에서 naver.com 와 같은 링크를 검색한 경우

`https://www.naver.com`

### 우선 웹 브라우저가 도메인명의 IP 주소를 조회합니다.
브라우저에 URL을 입력하고 확인, Enter 키를 누르면 브라우저는 인터넷에서 연결할 서버를 파악합니다. 입력한 도메인을 사용해 웹 사이트를 호스팅 하는 서버의 IP 주소를 조회해야 합니다. DNS 조회를 사용해 이 작업을 수행합니다. DNS는 복잡하고 매우 빨라야 해서 DNS 데이터는 웹 브라우저 사이의 서로 다른 계층과 인터넷의 다양한 위치에 임시로 저장됩니다. 이는 캐시(Cache)로 웹 브라우저는 고유한 캐시, 운영 체제 캐시, 라우터의 로컬 네트워크 캐시, 회사 네트워크 또는 인터넷 서비스 제공업체(ISP)의 DNS 서버 캐시를 확인합니다.

만약, 웹 브라우저가 캐시 계층에서 IP 주소를 찾을 수 없는 경우 회사 네트워크 또는 ISP의 DNS 서버가 재귀적 DNS 조회를 수행합니다. 재귀적 DNS 조회는 인터넷에 있는 여러 DNS 서버를 요청하며, 검색될 때까지 DNS 레코드에 대해 더 많은 DNS 서버에 요청합니다. 웹 브라우저가 IP 주소로 DNS 레코드를 가져오면 인터넷에서 서버를 찾아 연결을 설정해야 합니다.

### 그리고 웹 브라우저가 서버와의 TCP 연결을 시작합니다.
인터넷에 연결된 웹 브라우저 요청 패킷은 일반적으로 TCP/IP 라고 하는 전송 제어 프로토콜을 통해 라우터 장비, 인터넷 서비스 제공회사 교환기를 통해 이동되어, 통신 회사 간 경로인 라우팅 테이블을 따라서 연결할 IP 주소가 있는 웹 서버를 찾습니다. 그러나 요즘엔 웹 서버에 직접 도달하는 방법 대신 많은 웹 사이트들이 직접 서버에 연결하기 보다는 콘텐츠 전송 네트워크(CDN)를 사용하여 정적 및 동적 콘텐츠를 웹 브라우저 가까이에 위치 시킵니다. CDN 배포의 원본이 설정되어 있다면 `xxx.naver.com` 이라는 도메인 주소가 설정되고, 사용자의 접속 요청 시 DNS 는 원본 서버가 아닌 콘텐츠 배포 연결 지점의 IP 주소를 반환합니다. 이 요청은 내 컴퓨터의 `www.naver.com` 으로 이동하는 홉을 추적하기 위해 `traceroute` 를 사용할 수 있습니다. 

웹 브라우저 요청은 인터넷 라우팅 테이블에 따라 경로를 따라서 순서대로 이동합니다. 각 요청은 가장 성능이 좋은 위치를 통해 지능적으로 라우팅 되어 브라우저에 콘텐츠를 전송합니다. 이때는 웹 서버는 원본 서버와 CDN 모두가 아닌 로드 밸런싱 기능을 이용합니다. 로드 밸런서는 여러 웹 서버의 부하 분산을 해주는 기능입니다.

웹 브라우저가 인터넷에서 서버를 찾게 되면 웹 서버와 TCP 연결 설정을 하고, HTTP 의 경우 평문 통신을 시작하지만 HTTPS를 사용하는 경우엔 주고 받는 데이터의 암호화를 위한 TLS(Transport Layer Security) 핸드셰이크라는 추가 과정을 수행합니다. 이 과정을 통해 암호화를 할 상호 대상을 확인합니다.

### 이제 웹 브라우저가 HTTP 요청을 서버로 전송합니다.
웹 브라우저가 서버에 연결되면, HTTP(s) 프로토콜에 대한 통신 규칙을 따릅니다. 웹 브라우저가 페이지의 콘텐츠를 요청하기 위해 서버에 HTTP 요청을 전송하는 것으로 시작합니다. HTTP 요청에는 요청 라인, 헤더(또는 요청에 대한 메타데이터) 및 본문이 포함됩니다. 요청 라인에는 브라우저가 수행하려는 작업을 서버가 결정하는 데 사용할 수 있는 정보가 포함되어 있습니다.

요청 라인에는 다음이 포함됩니다.

- `GET`, `POST`, `PUT`, `PATCH`, `DELETE` 또는 몇 가지 다른 HTTP 동사 중 하나인 요청 메서드
- 요청된 리소스를 가리키는 경로
- 통신할 HTTP 버전

URL 요청에 대한 요청 라인은 다음과 같습니다.

```GET /blog/1620 HTTP/1.1```

이 요청 라인은 서버에 `/blog/1620` 에서 리소스를 가져오고 `HTTP/1.1` 과 통신하기를 원한다고 알립니다.

HTTP 동사는 요청의 의미 의도를 표현하며 `POST`, `PUT` 또는 `PATCH` 메서드를 사용하여 요청 경로에서 새 데이터를 생성하거나 기존 데이터를 업데이트하기 위해 저장할 서버로 데이터를 전송할 수도 있습니다. `DELETE` 메서드는 지정된 경로에서 리소스를 삭제합니다. 그러나, 서버가 모든 동사를 지원할 필요는 없다는 점을 아는 것이 중요합니다.

요청 헤더(Request Header) 으로 헤더는 요청을 라우팅하는 데 도움이 되는 추가 정보를 클라이언트에서 전달하고, 어떤 유형의 클라이언트(사용자 에이전트)가 요청을 수행하는지 나타내며, A/B 테스트, 블루/그린 배포 및 카나리 배포를 지원하는 데 사용할 수 있습니다. 키-값 페어로 이루어져 있습니다.

요청의 마지막 부분은 본문입니다. 본문은 (보통) `GET` 요청에 대해 비어 있습니다. `POST`, `PUT` 또는 `PATCH와` 같은 리소스를 조작하는 요청의 경우 본문에는 생성하거나 업데이트할 클라이언트의 데이터가 포함됩니다. 요청 본문은 서로 다른 형식일 수 있으며 서버는 요청 헤더인 Content-Type을 기반으로 형식을 이해합니다.
웹 서버가 클라이언트로부터 요청을 받으면 서버는 요청을 처리하고 응답을 다시 전송합니다.

### 웹 서버가 요청을 처리하고 응답을 다시 전송합니다.
웹 서버는 요청을 받고 요청 라인, 헤더 및 본문의 정보를 기반으로 요청 처리 방법을 결정합니다. `GET /blog/1620 HTTP/1.1` 요청에 대해 서버는 이 경로의 콘텐츠를 가져오고 응답을 생성하여 클라이언트로 다시 전송합니다. 응답에는 다음이 포함됩니다.

- 클라이언트에게 요청 상태를 알려주는 상태 라인
- 브라우저에 응답 처리 방법을 알려주는 응답 헤더
- 해당 경로에서 요청된 리소스 (HTML, CSS, Javascript, 이미지 파일과 같은 콘텐츠 또는 데이터)
상태 라인에는 HTTP 버전과 요청 상태의 숫자 및 텍스트 표현이 모두 포함됩니다. 

응답의 예시입니다.
```
HTTP/1.1 200 OK
Date: Tue, 25 May 2021 19:40:59 GMT
Server: Apache
X-Frame-Options: SAMEORIGIN
X-Powered-By: Express
Cache-Control: max-age=0, no-cache
Content-Type: text/html; charset=utf-8
Vary: Accept-Encoding
X-Mod-Pagespeed: 1.13.35.2-0
Content-Encoding: br
Keep-Alive: timeout=1, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked

<!DOCTYPE html>
<html lang="ko">
<head>
    ...
```

200의 상태 코드를 성공했다고 판단합니다. 지금처럼 응답이 200 이기 때문에 브라우저가 응답을 렌더링 할 것입니다.
전송 받은 리소스는 텍스트(예: `index.html`) 또는 텍스트가 아닌 데이터(예: `logo.img`)의 정적 파일일 수 있습니다. 웹 브라우저가 항상 정적 파일을 요청하는 것은 아닙니다. 대부분 웹 서버가 동적 리소스를 생성하여 코드 조각이나 템플릿에서 HTML을 구축하고 동적 데이터와 결합하여 응답으로 텍스트로 다시 전송하여, 웹 브라우저가 페이지를 렌더링할 수 있습니다.

지금까지는 서버가 브라우저로 다시 전송하기 위해 응답을 구축하는 방법이었습니다. 이제부터 웹 브라우저가 응답을 어떻게 처리하는지 살펴보겠습니다.

### 웹 브라우저가 콘텐츠 렌더링을 진행합니다.
웹 브라우저가 서버로부터 응답을 받으면 응답 헤더를 검사해 리소스를 렌더링하는 방법에 대한 정보를 확인합니다. 위의 `Content-Type` 헤더는 브라우저에 응답 본문에서 HTML 리소스를 수신했음을 알립니다. 

첫 번째 `GET` 요청은 페이지의 구조인 HTML을 반환합니다. 그러나, 웹 브라우저의 개발 도구를 사용하여 페이지(또는 웹 페이지)의 HTML을 검사하면 다른 Javascript, CSS, 이미지 리소스를 참조하고 웹 페이지를 설계된 대로 렌더링하기 위해 추가 데이터를 요청하는 것을 볼 수 있습니다. 브라우저가 HTML을 파싱하고 렌더링할 때 Javascript, CSS, 이미지 및 데이터를 가져오라는 추가 요청합니다. 이 중 많은 부분을 병렬로 수행할 수 있습니다.
HTML은 CSS나 JS 파일 리소스를 참조합니다. 웹 브라우저는 페이지에 스타일을 지정하기 위해 이 CSS 리소스를 가져오도록 서버에 후속 요청을 합니다. CSS 리소스에 대한 요청에 대한  `Content-Type` 헤더는 브라우저에 CSS를 렌더링하도록 지시합니다.

만약, 웹 브라우저가 이미지 리소스를 요청하면 `Content-Type` 헤더가 브라우저에 텍스트가 아닌 데이터임을 알려주고 그에 따라 렌더링하도록 지시합니다.


## 최종적으로 정리해봅니다.

1. 웹 브라우저에 URL을 입력하고 Enter 키를 누릅니다.
2. 웹 브라우저가 도메인의 IP 주소를 조회합니다. 캐쉬를 먼저 찾고 없다면 DNS를 겁색합니다.
3. 웹 브라우저가 찾은 IP주소를 기반으로 서버와의 TCP 연결을 시작합니다.
4. 웹 브라우저가 HTTP 요청을 서버로 전송합니다. HTTPS의 경우 보안 통신을 진행합니다.
5. 웹 서버가 요청을 처리하고 응답을 다시 웹 브라우저로 전송합니다.
6. 웹 브라우저가 전송을 받은 콘텐츠를 렌더링합니다.

[참고 및 출처]
https://aws.amazon.com/ko/blogs/korea/what-happens-when-you-type-a-url-into-your-browser/
https://searchadvisor.naver.com/guide/seo-basic-intro